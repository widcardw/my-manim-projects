tutorial #1  从矢量到updater

本教程仅为up个人对于代码的理解,有些部分可能并非准确,敬请谅解

首先,在讲updater之前要先讲一些前置知识,或者说是manim对于动画实现的一些细节

1.矢量图 Vector
在manim中,我们所能看到的这些图像,包括直线,曲线,圆,多边形等等,
这些图形大多都是用矢量图绘制的,它们对应了manim中的一个类VMobject
它有一个特点:不管怎样放大,它都不会失真
而矢量图的存储,对于这些简单的几何图形,在某种程度上,可能会比较方便一些
就拿最简单的例子来说,我需要一张图片上有一条圆形的路径,
对于矢量图,只需要记录它的线条和图块,即可用有限的数据来表示一个圆
想要生成矢量图,只需要想想画图时候用到的钢笔工具,用锚点和手柄,即可确定一条贝塞尔曲线
而在manim中,曲线正是通过锚点生成的,想要修改曲线,我们只需要修改这些点,
就可以牵一发而动全身(动一个极小的部分就影响全局)
而对于位图,例如png图片,它每个像素都包含了RGBA四个参数(当然实际上肯定不止),
你需要在一张有限大的图片上,将所有像素点的数据记下来,
最终才能显示出一张精度有所缺失的路径
(当然在这里也不是贬低位图,例如照片等等这些类型,如果用矢量来存储,肯定是得不偿失)

2.插值 interpolate
刚才讲到了图像和坐标,这些都只是静态的,而想要让画面动起来,当然少不了它:补间
从我们小学学过的(现在已经死亡的)Flash中,我们可能接触到这么一个词:补间动画
补间动画可以从字面意思上去理解:补足图像中间过程的动画
来看一个正方形平移的例子,这可以看作是这个图形从A点到B点的补间
而实现这个动画的方式,就是插值
找到初始点和结束点,传入alpha,让alpha从0线性变换到1,这便是最简单的插值
而刚才提到了矢量图,或者严格一点来说是manim中的矢量图,
它是通过锚点的坐标来确定图形的样貌的
而如果我们将两个图形的锚点一一对应地组合起来,对每个组合进行线性插值
这便形成了manim中最为核心的动画之一:Transform
那要是两个矢量图的锚点数量不相等怎么办?
很简单,对锚点较少的那个图形的锚点进行插值就可以了
当然,这里的插值就不仅仅局限于运动的起止点了

3.对象 object(不是配偶)
与C语言不同,python是一门面向对象的编程语言,或许在某种层面上可以说,这里万物皆对象
这不局限于整型数,字符串,自定义class,连你写的函数也是对象
所以在有些方法中,你要写的并不是已经传入实参的函数,而是只有一个函数名

*.引入概念 target 代表一个物件在下一个时间点,它要变成什么样子
math object有一个方法,叫做generate_target,使它生成一个目标
此时这个目标还是自己,我们可以通过一些方法改变这个target
然后使用MoveToTarget将它变为目标的样式
这样分步写看上去相对清晰,但是也比较繁琐
而我们将这几条结合到一起,就变成了 传入方法(method)
当我们用这样的方式来创建动画,实际上,我们传入的是一个函数对象,
后面的字典即为这个函数中要传入的参数
在Scene类的play方法中,上述的函数对象对应的方法将会被翻译为动画对象的实例
或许用代码的方式要比口述更加清晰
mobject.generate_target()
func(mobject.target, **kwargs)
MoveToTarget(mobject)
或者熟悉一点的方式,Transform(mobject, mobject.target)
来看一个例子,是两种动画的对比,我们需要让正方形绕原点逆时针旋转180度
第一种,我们采用Rotating的类,而第二种,我们采用的是rotate的方法
传入相同的参数,我们看看有什么区别
很明显,第一种方法达到了我们的目的,而第二种只是从初始到终止,生成了一段补间动画
我们将这两种动画翻译一下
可以看出,第二种相对比较简单,就相当于直接对两种状态进行线性插值
而第一种看上去相对要晦涩难懂一些
/*它将某个插值函数重写,变成了在圆弧路径上的插值*/
实际上,它和第二个的区别就在于插值函数,
通过函数运算得到每一帧的画面,
前者的轨迹为直线,后者的轨迹为圆弧
//后者为直线运动,而前者为旋转运动
//或者简单来说,它们的起止点相同,只不过插值不同罢了

好了,终于可以开始正式的updater教程了
我们从最简单的例子开始,让一条文本跟随点一起运动
在这里,我们已经利用next_to的方法,让文本在点的右边了
但是点运动起来,文本却还留在原地,这时就需要用到updater了
编写一个函数,传入一个参数,这个参数代表的就是需要更新的物件
让物件在点的右边,最后给文本加上add_updater这个方法,传入这个函数的对象,
就可以让文本时刻保持在点的右边
这一过程可以理解为,
在点的动画创建的同时,给文本生成了目标,
并将anim作为文本动画的插值函数
在alpha变化时生成相应的画面
在感官上,就是将每一帧的画面都计算出来,呈现在屏幕上

/*
在每段动画执行的过程中,都会给这个文本创建target
而在点运动的时候,会将next_to作为一个函数,来充当文本动画的插值函数
*/
/*
这一过程可以理解为,在每一帧计算机都会算出文本下一帧的状态,
并且以下一帧为target,将当前一帧的动画过渡到下一帧
而我们肉眼所看到的,就是计算机整个运算的过程
*/

同样,我们可以通过使用remove_updater将刚刚这个更新删除

当然,如果是这样一些简单的动画,我们更常用的是传入一个匿名函数
当不需要更新动画的时候,利用clear_updater,将所有的更新删除
